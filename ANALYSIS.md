CompSci 308: SLogo Analysis
===================

> This is the link to the assignment: [SLogo](http://www.cs.duke.edu/courses/compsci308/current/assign/03_slogo/)


Design Review
=======

### Overall Design

* Describe the overall design of the complete program:


1. What is the high level design of each part (front and back end) and how do they work together (i.e., what behavior, data, or resources each part depends on from the others).

	The Controller receives the user input as a string from the front end GUI and passes it to the Parser. The Parser provides a token list of the user input, which includes a list of literals and another list of corresponding Logo types (ex: fd 50 tokenized into [fd, 50] as literals and [Forward,Constant] as Logo types). The Controller uses this to assign commands to the appropriate turtle(s) in the form of a map. Then it goes through the map and send the appropriate turtle state info and corresponding token list to the Compiler, which would instantiate the command classes as TreeNode objects, organize them in a tree, and send back a queue of commands as tree nodes for the Model Controller to execute. The turtle state are observables to their observer counterparts on the front end, so any change will be reflected on the GUI display.

2. Is the code generally consistent in its layout, naming conventions and descriptiveness, and style? Give specific examples for or against by comparing code from each team member.

	The code style is consistent among the team members. The names of variables are descriptive such as `myTurtles` in model.Model Controller that is the list of all turtle objects. A small difference is that on the front end classes ( 'gui' package ), most variables' names start with an underscore such as `_scene`, or `_displayView` (in gui.UIMain). Some classes are fairly long such as gui.UIMain but contain no extremely long method. 
		
3. What is needed to add one of the following: a new command to the language, a new component to the front end, and a feature from the specification that was not implemented (include all the parts of the code or resources that need to be changed)?

	To add a new command, a command class needs to be created that implements the Command Interface and extends either the TurtleCommand or LogicCommand abstract class which extend the TreeNode abstract class ( the categorization is to differentiate between commands that require turtle state info such as Forward and those that don't such as Product). The name of the new command should be added in the language files, along with the number of arguments of the command in resources.NumArgs.properties and the location of the command class in resources.Locations.properties for reflection. 

	Adding graphical features on the front end such as new images, animation speed are independent of the backend. Any front end feature that can be dictated by commands such as background color or line color can be added by adding method into the BackEndHandler interface that the Model Controller provides to the `execute( BackEndHandler myHandler )` method of the appropriate command class

	A feature that we did not have enough time to implement is loading and saving SLogo functions/variables as a text file. For saving, the front end gui classes already has a Function and Variable boxes that contain all user-defined functions and variables with implementations details that can be outputted as a text file. For loading, the GUI can take in a text file as a string input and send it to the Controller to process. 
		
4. Are the dependencies between the parts clear and easy to find (e.g., public methods and parameters) or do they exist through "back channels" (e.g., static calls, order of method call, sub-class type requirements)?

	The dependencies between parts are clear. Specifically, there are no static calls or methods that call on and depend on many other methods from different parts of the program. 


* Describe two components that you did not implement:


1. Which is the most readable (i.e., whose classes and methods do what you expect and whose logic is clear and easy to follow)? Give specific examples.

	parser.reflection.ClassGenerator: reflection utilized by the compiler to create command classes as TreeNode objects based on their names. It is clear that this class checks if the command is an instance of model.command.TurtleCommand or not and pass in the constructor of that command object the turtle state info if it is. Method names such as  `isTurtleCommand(classname)` and `makeConstructor` help understanding this component's functionality.

	parser.main.NewParser: the parsing process that takes in the user input as a string and returns the tokenized list of the commands parsed from that string. This class is concise and clear: the `parse(String toParse)` takes in the string input and return a `ProtectedTokenList` object.  The list is generated by a new instance of `TokenListGenerator`  that takes in the string and the language. 


2. Which is the most encapsulated (i.e., whose implementation you feel can be most easily changed without affecting the rest of the program)? Give specific examples.

	The NewParser returns the token list of commands as `ProtectedTokenList` which is unmodifiable by other components ( see parser.tokenizer.ProtectedTokenList class, the modifiable version is parser.tokenizer.TokenList). In this way, the data of the list is encapsulated and would not affect the rest of the program if the TokenList is changed within the parser, since what other component gets is always the ProtectedTokenList type. 

3. What have you learned about design (either good or bad) by reading your team mates' code?

	From others' code, I learn that a good practice is to create an unmodifiable version of data of a component that needs to be read only by other components. Making interface or using built-ins such as `Collections.unmodifiableList` are good approaches for that. 



### Your Design

* Reflect on the coding details of your part of the project.

1. Describe how your code is designed at a high level (focus on how the classes relate to each other through behavior (methods) rather than their state (instance variables)).

	Referring to package `model`: 
		
	**Command classes**
		
	Each command class implements the model.command.Command Interface and extends either the TurtleCommand or LogicCommand abstract class (or technically, extends the model.command.TreeNode abstract class). 

	The Command Interface has a single method `public void execute(BackEndHandler myHandler)` that apply the effect on the turtle state (update turtle's position, line color etc). 
				
	The TreeNode abstract structure allows commands to be represented on a tree in the parser. Each node has a list of children and a boolean `root` that defines if the node is a root in the parsing tree (this is for the parsing component).  An important feature of this abstract structure is the  `public double getValue()` method that returns the double value corresponding to the commands. For fd 50 as example, the fd command node in the tree takes 50 as its child node, and `getValue()` returns 50. Note that 50  is an instance of model.command.Constant that also extends TreeNode. 

	Each command class then has two important methods `execute(BackEndHandler myHandler)` and `getValue()`  in its implementation. Depending on the type it is casted, it can invoke appropriate functionality in different component of the program. 

	**Turtle classes**

	model.turtle.Turtle is the class for the backend Turtle object that has a state. 

	The model.turtle.TurtleState class contains the properties of the turtle such as position, head angle, pen color and so on. It extends the Observable design pattern and will be attached to an Observer on the front end so that any change in the back end state will be reflected and notified to the front end. The TurtleState also implements the model.turtle.State interface, which is a generic state interface that contains only getters for turtle's properties to allow for safe passing of the state to other components. 

	**Model Controller**
	
	model.ModelController manages all Turtles and executes commands returned from the parser/compiler component. It has methods for controlling turtles such that `makeNewTurtle(double id)` and `setActiveTurtles(List<Double> actives)` that the Controller can use when handling commands to multiple turtles. It also provides access to the unmodifiable lists of active turtles, turtle ids for other components. 

	The `update(Queue<TreeNode> commandsToExecute)` method takes in a queue of commands as TreeNode type. It casts these tree nodes as Command type to call the `execute` method. Note that the Model Controller receives a handler from the Controller, which it would pass into this `execute` method of each command class. The handler (see controller.BackEndHandler) is for any command operation that does not apply on the turtle  but rather the GUI features such as SetBackGround, SetPalette.	It also updates the double `myOutput` to be printed out on the terminal as the value of `getValue()` from the last TreeNode to be removed from the queue.

   ```java
   public void update(Queue<TreeNode> commandsToExecute){
      myOutput = "";

      while(!commandsToExecute.isEmpty()){ 
        TreeNode command= commandsToExecute.remove();
        ((Command) command).execute(myHandler);
        myOutput = ((Double) command.getValue()).toString();

      }
    }
    ```
 * Describe two features that you implemented in detail â€” one that you feel is good and one that you feel could be improved:

	A feature that I implemented and felt is good is the inheritance structure of each command class as mentioned above. 

	The incentive is that the parser component needs to be able to instantiate command classes and order them in a tree structure to support nested command. In order to parse `fd xcor` for example, the tree needs to know the current x-coordinate of the turtle which comes from its state. Extending the variants of the TreeNode abstract class allows both `fd` and `xcor` to be presented as tree nodes so that they will be returned as an in order queue for execution later. The constructor is flexible in that it will take in a list of nodes if it is a LogicCommand instance and add in a State object representing the read only state info of the turtle if it is a TurtleCommand instance. The outer `fd` node takes in its constructor the list of child nodes which is `xcor` and turtle state info, and the `getValue()` of `xcor` child node gives the double x-coordinate as argument for the `fd` node. 

	The command classes also implement the Command Interface to provides implementation  to the `execute` method. Having the execution method from this interface prevents the parser component from being able to call execute.  Even if the parser casts the TreeNode class to Command type, `execute` method still needs a `BackEndHandler` object as argument which the parser does not have.

	Separating `getValue()` and `execute` is important to handle condition commands such as `IFELSE xcor [ fd 20 ] [ rt 50 ]` when the parser needs to evaluate if `xcor` is 0 or not by using `getValue()` before deciding which list to run and send that list as a queue of command nodes to the model to execute. 

	When the Model Controller receives the command nodes, it casts them to Command type and call `execute(BackEndHandler myHandler)`. By then, the command class already knows which turtle state to apply effect on. If the command is a LogicCommand such as `product 20 30`, the void `execute` method still runs without doing anything, since it does not change any turtle. The BackEndHandler provides a way for any command that needs to call changes to the GUI such as setting background color, overriding palette. This design thus provides the consistency across all command classes. regardless of their effects. 

	Also this design allows for catching error conveniently. For example, natural log command class will throw a `SLogoException` if the child node value is a negative constant, with a customized message. The error is caught and displayed in the Controller class after input is processed. This follows the assumption that the program will execute commands until the wrong one that throws error. The users have to look at history of executed commands to reverse any command if they want to return to the state previous to executing input that contains error.  

	The `getValue()` of the model.math.NaturalLog class, where error is thrown.
  
   ```java
    public double getValue(){
      Double val = Math.log(children.get(0).getValue()); // value of x in ln(x) cannot be negative, throw error here 
      if (val.isNaN()||val.isInfinite()){
        throw new SLogoException("Invalid value for natural log: " + children.get(0).getValue());
      }
      else{
        return val;
      }
    }
   ```
   The `processInput(String input)` in controller.Controller where error is caught and call for display
   		
   ```java
		private void processInput(String input){
				try{
					//...
					for (Double turtleId: turtlesToCommands.keySet()){		
						ProtectedTokenList commandsToApply = turtlesToCommands.get(turtleId);		
						TurtleState t = findTurtle(turtleId);
						Queue<TreeNode> Q = compiler.compile(t, commandsToApply); 
						myModel.update(Q);			
						output = myModel.getStringOutput();
						myViewController.addNewOutput(output);				
					}			
					myViewController.getFunctionsBox().setFunctionBox(compiler.getFunctionList());
				}
				catch (SLogoException e){ 
					myViewController.displayErrorWithMessage(e.getMessage());
				}
				output = myModel.getStringOutput();
			}
	  ```
   A feature that could be improved is the model.ModelController. 

   Currently, the Controller instantiate the ModelController class and passes that instance to the SubListProcessor and the MapMaker instances from the parsing component. These classes are responsible for handling Ask/Tell which assigns commands to appropriate turtles and create/set active turtles when needed. 

	 Passing in the whole ModelController instance is unsafe since it contains `update`, `reset` that are important backend methods that those parser classes should not be able to call. A ProtectedModelControllerInterface that contains only methods from ModelController required by SubListProcessor and the MapMaker would be safer. 

	 Also, the `public Turtle makeNewTurtle(double id)` method should check for existence of turtle before making a new one to avoid duplication. Even though the MapMaker class does check for turtle existence before calling this method, it is better to do it within the method itself as ModelController conveniently holds the list of all turtles and some other component of the program may invoke this method without checking for existence. 

### Flexibilty
* Reflect on what makes a design flexible and extensible.

1. Describe what you think makes design more flexible (i.e., able to support adding similar features easily) and how you think this is reflected (or not) in the project's design.
  I think what makes design more flexible is the separation of front end and backend as well as effective communication between different components. 

	In our design, the front end (gui package) is separated from the backend in its implementation, with the Controller responsible for communicating the two parts . The Controller structures the flow of the program, instantiate the GUI, Parser, and Model. It takes string input from front end and pass to the parser which gives back a queue of commands to be executed by the model. The back end model notifies the change of turtle state through the Observable/Observer pattern to the front end, which uses that info and visualizes. Any graphical feature specific to GUI is implemented independently of other program components ( animation of the turtle, sliding menu, history and vocab box etc). 

	This design thus makes adding features is easy and flexible. For example, if we want to have a command that dictates the turtle animation speed, it could be added as a double variable in the backend turtle state and the front end observer can get that info automatically. 

* Describe two features from the assignment specification that you did not implement in detail:

1. What is interesting about this code (why did you choose it)?
2. What classes or resources are required to implement this feature?
3. Describe the design of this feature in detail (what parts are closed? what implementation details are encapsulated? what assumptions are made? do they limit its flexibility?)
4. How extensible is the design of this feature (is it clear how to extend the code as designed? what kind of change might be hard given this design?)


	**Supporting multiple languages feature**

	This code is interesting because it involves multiple parts of the program. The user chooses the language in the menu slider at the front en , which notifies the parser of the new language. The parser knows how to parse the string and return them the same way as they do with default language for the backend to execute. 

	To implement this feature, the front end implements a combo box whose options are names of all languages from the `resources.languages` package. The UIMain receives a controller.ControlHandler handler object when it was instantiated by the Controller. It passes this handler to gui.menu.UIMenuView instance in which the combo box is implemented. Any time the language is selected, the UIMenuView calls `_handler.setLanguage (string newLanguage) ` method, which invokes the `changeLanguage(string newLanguage)` in the Controller. This method would reinstantiate the parser object and pass in the string representing the new language in so that the parser can read from the appropriate resource file and identify the command. 

	In gui.UIMenuView in the `	private void setupLanguagePicker()` method
  
   ```java
	private void setupLanguagePicker()
	...
	ComboBox<String> menu = new ComboBox<String>();
	...
		menu.setOnAction((event) -> {
    			String s = menu.getSelectionModel().getSelectedItem();
    			_handler.setLanguage(s);
    		});
	  ```
   the `setLanguage` method of the handler invokes `changeLanguage` in Controller 

	  ```java 

		private void changeLanguage(String language) {
		currentLang = new StringBuilder(); 
		currentLang.append(languageLocation);
		currentLang.append(language);
		myParser = new NewParser(currentLang.toString());
	}
	  ```
   Having a handler to the Controller in this way prevents the front end from having access to the parser. The actual reinstantiation of parser with the new language happens within Controller which manages and encapsulates it. As long as all resource language bundle files are in the same package, extending new language is easy as we just need to add the new language file in the form of `languageName.properties`, and UIMenuView would automatically adds the language name as a new option in the combo box .

	**Variable Boxes**

	The feature of storing and displaying variables in a GUI box is interesting because it also shows how the different components of the program connect.

	The Controller instantiates the compiler, which is responsible for storing variables as a parser.storage.VariableStorage type object. This type class essentially holds a map of string to value for variable and extends the Observable pattern. 

	In its constructor, the Controller calls `private void configureVariableStorage()` method to set the observable/observer relationship between this VariableStorage object and the front end variable box component gui.tableviews.UIVariablesView. 

	In Controller: 
  
   ```java
		private void configureVariableStorage() {
		VariableStorage vars = compiler.getVars(); 
		UIVariablesView variableBox = myViewController.getVariableView();
		vars.addObserver(variableBox);
		}
	 ```
	
	Thus, updates on the variable storage would be reflected onto the UIVariablesView automatically. The front end just needs to display the information from the storage, and leaves the handling of variables overriding and instantiating to the back end storage. This makes extension flexible because the rules of variable handling can be changed or added to within the backend that does not involve with the front end. 


### Alternate Designs

* Describe how well (or poorly) the original design handled the project's extensions to the original specifications and how these changes were discussed and decisions ultimately made.

	The original design handles the project's extensions fairly well. Setting up additional turtle commands such as SetPenColor, SetShape, SetPenSize only requires adding to the existing backend TurtleState variables such as myPenColor, myShape, and so on. The  `execute()` of each command from original design now takes in a handler to be `execute (BackEndHandler myHandler)` that can accommodate any command that modifies GUI such as SetPalette or SetBackground. 
		
	For multiple turtles, the only change is to replace the unique `myTurtle` to a dynamic list of Turtle objects within the ModelController then provides methods to add and set active turtle. This list of turtle and methods will be used by the controller to parse Ask/Tell that will assign commands to appropriate turtles. 

*  Describe two design decisions discussed about any part of the program in detail:

1. What alternate designs were proposed?
2. What are the trade-offs of all the design choices (describe the pros and cons of the different designs)?
3. Which would you prefer and why (it does not have to be the one that is currently implemented)?

    Decision #1 
		
    The commands that deal with GUI component such as SetPalette, need  access to the GUI which holds the Palette objects for their `execute` methods. One way we discussed is to pass a reference of the GUI to the parser component which would pass GUI reference to the constructor of each command. However, this way allows the parser component to have access to important methods of the GUI that it should not have, and the idea of passing a reference of the GUI to each command class is unsafe and creates unnecessary dependencies. The way we decided is to create a BackEndHandler that the Controller can pass to ModelController and to the `execute` method. This decision maintains the consistency of command without exposing GUI to other components. The handler interface only allows a command does a certain operations and can be easily extended. 

	controller.BackEndHandler
		
	 ``` java
	public interface BackEndHandler {
	public void setBackground(double index);
	public void setPalette(double index, double r, double g, double b);
	public void handleReset();
	public double getNumTurtle();
	public void setRelationship(Double id);
	}

	 ```
	

	Whether a command uses this handler does not matter as it is passed in execute method of every command for consistency. In the case of SetPalette for example, the `execute` method will be:

	 ```java
		public void execute(BackEndHandler myHandler) {
					myHandler.setPalette(children.get(0).getValue(),children.get(1).getValue(
				),children.get(2).getValue(),children.get(3).getValue());
		}
	 ```	

	Decision # 2
		
	Another design decision is about implementing dragging of turtle on display by mouse. For this, we thought of converting the movement of turtle on display by mouse into commands and running them internally. However, that would require having a compiler to instantiate command class on the front end which provides unnecessary access to the parser component classes. 

	Since we already use the observable pattern for listening to changes in turtle state from the backend, we decided that the front end observer can cast the observable object to TurtleState type instead of the read only State from the original design. This provides GUI access to setter methods of turtle positions. Dragging turtle by mouse can then call the setters to change turtle state directly and conveniently. 


### Conclusions

* Reflect on what you have learned about designing programs through this project, using any code in the project as examples:

1. Describe the best feature of the project's current design and what did you learn from reading or implementing it?

	The best feature is the parsing, which works really well with other components and extensible. The parser component utilizes reflection to create command class by reading the literals of the user input. It represents commands as TreeNode type and organize them in a tree to accommodate nested command and return an in-order queue of command tree node to send back for execution. By utilizing resource bundle, it return command queue in the same format regardless of the language. This component's implementation shows that it is important to be consistent in dealing with data. Using design pattern and good inheritance hierarchy through interface, abstract class, we can disregard the specific implementation of variants of data and treat them universally, thus making the program modular and flexible. 

2. Describe the worst feature that remains in the project's current design and what did you learn from reading or implementing it?

	Handling Ask/Tell by the Controller: The bad thing about this feature is that the Controller gets the list of token representing the user input and it finds position of any ask or/and tell in the list and extract the commands after them to assign to turtle. This approach seems a bit hard coded since the program actually has special classes to handle these two commands only. However, it seems to be the only choice at the time. 
		
3. To be a better designer in the next project, what should you
		
	*start doing differently*

	I will look at ways to make my classes more generalized and encapsulated through utilizing interfaces. I also should research on different design patterns in implementing a feature and discuss with my teammates to find the best option that is most flexible.

	*keep doing the same*

	Passing interface instead of the whole instance of variable, such as `State` that provides read-only access to `TurtleState`. Using interface hides the methods of the instance that other component don't need.
	Be clear about my component's APIs, what it can give and what it needs to function. This is important thing I have been doing in this project to avoid confusion and set clear specifications for my teammates
		
	*stop doing* 
		
	Not looking over other's design for their part sometimes. I raised concern over the design of the Controller in the third sprint a bit too late when there was not much time left to think of a new design and implement. I also wrote a few methods from my part that do the same job as those from others because of this. Thus, I should keep track of all the program design constantly next time


> Written with [StackEdit](https://stackedit.io/).
   
  
